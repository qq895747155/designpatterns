package com.handl.behaviouraltype.fangwenzhe;

/**
 * Created by handl on 2017/9/29.
 *
 * 访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，
 *          接受这个操作的数据结构则可以保持不变。
 *
 *
 *          抽象访问者(Visitor)角色：声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口。
            具体访问者(ConcreteVisitor)角色：实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作。
            抽象节点(Node)角色：声明一个接受操作，接受一个访问者对象作为一个参数。
            具体节点(ConcreteNode)角色：实现了抽象节点所规定的接受操作。
            （可以没有）结构对象(ObjectStructure)角色：有如下的责任，可以遍历结构中的所有元素；
                    如果需要，提供一个高层次的接口让访问者对象可以访问每一个元素；
                    如果需要，可以设计成一个复合对象或者一个聚集，如List或Set。
------------------------------------------------------------------------------------------------------------------------
 * 分派的概念
 　　变量被声明时的类型叫做变量的静态类型(Static Type)，有些人又把静态类型叫做明显类型(Apparent Type)；
        而变量所引用的对象的真实类型又叫做变量的实际类型(Actual Type)。比如：
         List list = null;
        list = new ArrayList();
 　　     声明了一个变量list，它的静态类型（也叫明显类型）是List，而它的实际类型是ArrayList。
 　　根据对象的类型而对方法进行的选择，就是分派(Dispatch)，
     分派(Dispatch)又分为两种，即静态分派和动态分派。
 　　     静态分派(Static Dispatch)发生在编译时期，分派根据静态类型信息发生。
            静态分派对于我们来说并不陌生，方法重载就是静态分派。
 　　     动态分派(DongTaiDaiLiProxy Dispatch)发生在运行时期，动态分派动态地置换掉某个方法。
------------------------------------------------------------------------------------------------------------------------
 *
 * 什么是访问者模式？
        比如我有一个账单，账单有收入，支出两个固定方法。但是访问账单的人不确定，有可能是一个或者多个。
   访问者模式有两个特点
        一般被访问的东西所持有的方法是固定的，就像账单只有收入和支出两个功能。而访问者是不固定的。
        数据操作与数据结构相分离：频繁的更改数据，但不结构不变。
                比如：虽然每一天账单的数据都会变化（数据变化），
                    但是只有两类数据，就是支出和收入（结构不变）。

        账单就是节点对象
        访问账单的人就是访问者对象


        例子：账单(节点对象，提供支出和收入接口)，访问者(老板，财务)

        1.访问者对象，Visitor：定义对所有节点接受和操作接口
        2.访问者实现类：BossVisitor,CaiWuVistor
        3.节点抽象类，Bill(账单)，定义接受访问者的接口
        4.具体节点类，ZhiChuBill,ShouRuBill
        5.节点结构对象ObjectStructure
 *
 */
public class Test {

    public static void main(String[] args) {
        //结构类
        ObjectStructure structure = new ObjectStructure();
        structure.add(new ShouRuBill(3000));
        structure.add(new ZhiChuBill(2000));

        //通过结构类循环调用所有节点
        structure.accept(new BossVisitor());
        structure.accept(new CaiWuVistor());
    }
}
